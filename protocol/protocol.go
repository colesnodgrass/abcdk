// Code generated by github.com/atombender/go-jsonschema, DO NOT EDIT.

package protocol

import "encoding/json"
import "fmt"
import "github.com/go-viper/mapstructure/v2"
import "reflect"
import "strings"

// A message to communicate usage information about the connector which is not
// captured by regular sync analytics because it's specific to the connector
// internals.
// This is useful to understand how the connector is used and how to improve it.
// Each message is an event with a type and an optional payload value (both of them
// being strings). The event types should not be dynamically generated but defined
// statically. The payload value is optional and can contain arbitrary strings.
type AirbyteAnalyticsTraceMessage struct {
	// The event type - should be a static string. Keep in mind that all strings are
	// shared across all connectors.
	Type string `json:"type" yaml:"type" mapstructure:"type"`

	// The value of the event - can be an arbitrary string. In case the value is
	// numeric, it should be converted to a string. Casting for analytics purposes can
	// happen in the warehouse.
	Value *string `json:"value,omitempty" yaml:"value,omitempty" mapstructure:"value,omitempty"`

	AdditionalProperties interface{} `mapstructure:",remain"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *AirbyteAnalyticsTraceMessage) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in AirbyteAnalyticsTraceMessage: required")
	}
	type Plain AirbyteAnalyticsTraceMessage
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	st := reflect.TypeOf(Plain{})
	for i := range st.NumField() {
		delete(raw, st.Field(i).Name)
		delete(raw, strings.Split(st.Field(i).Tag.Get("json"), ",")[0])
	}
	if err := mapstructure.Decode(raw, &plain.AdditionalProperties); err != nil {
		return err
	}
	*j = AirbyteAnalyticsTraceMessage(plain)
	return nil
}

// Airbyte stream schema catalog
type AirbyteCatalog struct {
	// Streams corresponds to the JSON schema field "streams".
	Streams []AirbyteStream `json:"streams" yaml:"streams" mapstructure:"streams"`

	AdditionalProperties interface{} `mapstructure:",remain"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *AirbyteCatalog) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["streams"]; raw != nil && !ok {
		return fmt.Errorf("field streams in AirbyteCatalog: required")
	}
	type Plain AirbyteCatalog
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	st := reflect.TypeOf(Plain{})
	for i := range st.NumField() {
		delete(raw, st.Field(i).Name)
		delete(raw, strings.Split(st.Field(i).Tag.Get("json"), ",")[0])
	}
	if err := mapstructure.Decode(raw, &plain.AdditionalProperties); err != nil {
		return err
	}
	*j = AirbyteCatalog(plain)
	return nil
}

// Airbyte connection status
type AirbyteConnectionStatus struct {
	// Message corresponds to the JSON schema field "message".
	Message *string `json:"message,omitempty" yaml:"message,omitempty" mapstructure:"message,omitempty"`

	// Status corresponds to the JSON schema field "status".
	Status AirbyteConnectionStatusStatus `json:"status" yaml:"status" mapstructure:"status"`

	AdditionalProperties interface{} `mapstructure:",remain"`
}

type AirbyteConnectionStatusStatus string

const AirbyteConnectionStatusStatusFAILED AirbyteConnectionStatusStatus = "FAILED"
const AirbyteConnectionStatusStatusSUCCEEDED AirbyteConnectionStatusStatus = "SUCCEEDED"

var enumValues_AirbyteConnectionStatusStatus = []interface{}{
	"SUCCEEDED",
	"FAILED",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *AirbyteConnectionStatusStatus) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_AirbyteConnectionStatusStatus {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_AirbyteConnectionStatusStatus, v)
	}
	*j = AirbyteConnectionStatusStatus(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *AirbyteConnectionStatus) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["status"]; raw != nil && !ok {
		return fmt.Errorf("field status in AirbyteConnectionStatus: required")
	}
	type Plain AirbyteConnectionStatus
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	st := reflect.TypeOf(Plain{})
	for i := range st.NumField() {
		delete(raw, st.Field(i).Name)
		delete(raw, strings.Split(st.Field(i).Tag.Get("json"), ",")[0])
	}
	if err := mapstructure.Decode(raw, &plain.AdditionalProperties); err != nil {
		return err
	}
	*j = AirbyteConnectionStatus(plain)
	return nil
}

type AirbyteControlConnectorConfigMessage struct {
	// the config items from this connector's spec to update
	Config map[string]interface{} `json:"config" yaml:"config" mapstructure:"config"`

	AdditionalProperties interface{} `mapstructure:",remain"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *AirbyteControlConnectorConfigMessage) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["config"]; raw != nil && !ok {
		return fmt.Errorf("field config in AirbyteControlConnectorConfigMessage: required")
	}
	type Plain AirbyteControlConnectorConfigMessage
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	st := reflect.TypeOf(Plain{})
	for i := range st.NumField() {
		delete(raw, st.Field(i).Name)
		delete(raw, strings.Split(st.Field(i).Tag.Get("json"), ",")[0])
	}
	if err := mapstructure.Decode(raw, &plain.AdditionalProperties); err != nil {
		return err
	}
	*j = AirbyteControlConnectorConfigMessage(plain)
	return nil
}

type AirbyteControlMessage struct {
	// connector config orchestrator message: the updated config for the platform to
	// store for this connector
	ConnectorConfig *AirbyteControlConnectorConfigMessage `json:"connectorConfig,omitempty" yaml:"connectorConfig,omitempty" mapstructure:"connectorConfig,omitempty"`

	// the time in ms that the message was emitted
	EmittedAt float64 `json:"emitted_at" yaml:"emitted_at" mapstructure:"emitted_at"`

	// the type of orchestrator message
	Type AirbyteControlMessageType `json:"type" yaml:"type" mapstructure:"type"`

	AdditionalProperties interface{} `mapstructure:",remain"`
}

type AirbyteControlMessageType string

const AirbyteControlMessageTypeCONNECTORCONFIG AirbyteControlMessageType = "CONNECTOR_CONFIG"

var enumValues_AirbyteControlMessageType = []interface{}{
	"CONNECTOR_CONFIG",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *AirbyteControlMessageType) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_AirbyteControlMessageType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_AirbyteControlMessageType, v)
	}
	*j = AirbyteControlMessageType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *AirbyteControlMessage) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["emitted_at"]; raw != nil && !ok {
		return fmt.Errorf("field emitted_at in AirbyteControlMessage: required")
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in AirbyteControlMessage: required")
	}
	type Plain AirbyteControlMessage
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	st := reflect.TypeOf(Plain{})
	for i := range st.NumField() {
		delete(raw, st.Field(i).Name)
		delete(raw, strings.Split(st.Field(i).Tag.Get("json"), ",")[0])
	}
	if err := mapstructure.Decode(raw, &plain.AdditionalProperties); err != nil {
		return err
	}
	*j = AirbyteControlMessage(plain)
	return nil
}

type AirbyteErrorTraceMessage struct {
	// The type of error
	FailureType *AirbyteErrorTraceMessageFailureType `json:"failure_type,omitempty" yaml:"failure_type,omitempty" mapstructure:"failure_type,omitempty"`

	// The internal error that caused the failure
	InternalMessage *string `json:"internal_message,omitempty" yaml:"internal_message,omitempty" mapstructure:"internal_message,omitempty"`

	// A user-friendly message that indicates the cause of the error
	Message string `json:"message" yaml:"message" mapstructure:"message"`

	// The full stack trace of the error
	StackTrace *string `json:"stack_trace,omitempty" yaml:"stack_trace,omitempty" mapstructure:"stack_trace,omitempty"`

	// The stream associated with the error, if known (optional)
	StreamDescriptor *StreamDescriptor `json:"stream_descriptor,omitempty" yaml:"stream_descriptor,omitempty" mapstructure:"stream_descriptor,omitempty"`

	AdditionalProperties interface{} `mapstructure:",remain"`
}

type AirbyteErrorTraceMessageFailureType string

const AirbyteErrorTraceMessageFailureTypeConfigError AirbyteErrorTraceMessageFailureType = "config_error"
const AirbyteErrorTraceMessageFailureTypeSystemError AirbyteErrorTraceMessageFailureType = "system_error"
const AirbyteErrorTraceMessageFailureTypeTransientError AirbyteErrorTraceMessageFailureType = "transient_error"

var enumValues_AirbyteErrorTraceMessageFailureType = []interface{}{
	"system_error",
	"config_error",
	"transient_error",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *AirbyteErrorTraceMessageFailureType) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_AirbyteErrorTraceMessageFailureType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_AirbyteErrorTraceMessageFailureType, v)
	}
	*j = AirbyteErrorTraceMessageFailureType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *AirbyteErrorTraceMessage) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["message"]; raw != nil && !ok {
		return fmt.Errorf("field message in AirbyteErrorTraceMessage: required")
	}
	type Plain AirbyteErrorTraceMessage
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	st := reflect.TypeOf(Plain{})
	for i := range st.NumField() {
		delete(raw, st.Field(i).Name)
		delete(raw, strings.Split(st.Field(i).Tag.Get("json"), ",")[0])
	}
	if err := mapstructure.Decode(raw, &plain.AdditionalProperties); err != nil {
		return err
	}
	*j = AirbyteErrorTraceMessage(plain)
	return nil
}

type AirbyteEstimateTraceMessage struct {
	// The estimated number of bytes to be emitted by this sync for this stream
	ByteEstimate *int `json:"byte_estimate,omitempty" yaml:"byte_estimate,omitempty" mapstructure:"byte_estimate,omitempty"`

	// The name of the stream
	Name string `json:"name" yaml:"name" mapstructure:"name"`

	// The namespace of the stream
	Namespace *string `json:"namespace,omitempty" yaml:"namespace,omitempty" mapstructure:"namespace,omitempty"`

	// The estimated number of rows to be emitted by this sync for this stream
	RowEstimate *int `json:"row_estimate,omitempty" yaml:"row_estimate,omitempty" mapstructure:"row_estimate,omitempty"`

	// Estimates are either per-stream (STREAM) or for the entire sync (SYNC). STREAM
	// is preferred, and requires the source to count how many records are about to be
	// emitted per-stream (e.g. there will be 100 rows from this table emitted). For
	// the rare source which cannot tell which stream a record belongs to before
	// reading (e.g. CDC databases), SYNC estimates can be emitted. Sources should not
	// emit both STREAM and SYNC estimates within a sync.
	//
	Type AirbyteEstimateTraceMessageType `json:"type" yaml:"type" mapstructure:"type"`

	AdditionalProperties interface{} `mapstructure:",remain"`
}

type AirbyteEstimateTraceMessageType string

const AirbyteEstimateTraceMessageTypeSTREAM AirbyteEstimateTraceMessageType = "STREAM"
const AirbyteEstimateTraceMessageTypeSYNC AirbyteEstimateTraceMessageType = "SYNC"

var enumValues_AirbyteEstimateTraceMessageType = []interface{}{
	"STREAM",
	"SYNC",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *AirbyteEstimateTraceMessageType) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_AirbyteEstimateTraceMessageType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_AirbyteEstimateTraceMessageType, v)
	}
	*j = AirbyteEstimateTraceMessageType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *AirbyteEstimateTraceMessage) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["name"]; raw != nil && !ok {
		return fmt.Errorf("field name in AirbyteEstimateTraceMessage: required")
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in AirbyteEstimateTraceMessage: required")
	}
	type Plain AirbyteEstimateTraceMessage
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	st := reflect.TypeOf(Plain{})
	for i := range st.NumField() {
		delete(raw, st.Field(i).Name)
		delete(raw, strings.Split(st.Field(i).Tag.Get("json"), ",")[0])
	}
	if err := mapstructure.Decode(raw, &plain.AdditionalProperties); err != nil {
		return err
	}
	*j = AirbyteEstimateTraceMessage(plain)
	return nil
}

type AirbyteGlobalState struct {
	// SharedState corresponds to the JSON schema field "shared_state".
	SharedState map[string]interface{} `json:"shared_state,omitempty" yaml:"shared_state,omitempty" mapstructure:"shared_state,omitempty"`

	// StreamStates corresponds to the JSON schema field "stream_states".
	StreamStates []AirbyteStreamState `json:"stream_states" yaml:"stream_states" mapstructure:"stream_states"`

	AdditionalProperties interface{} `mapstructure:",remain"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *AirbyteGlobalState) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["stream_states"]; raw != nil && !ok {
		return fmt.Errorf("field stream_states in AirbyteGlobalState: required")
	}
	type Plain AirbyteGlobalState
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	st := reflect.TypeOf(Plain{})
	for i := range st.NumField() {
		delete(raw, st.Field(i).Name)
		delete(raw, strings.Split(st.Field(i).Tag.Get("json"), ",")[0])
	}
	if err := mapstructure.Decode(raw, &plain.AdditionalProperties); err != nil {
		return err
	}
	*j = AirbyteGlobalState(plain)
	return nil
}

type AirbyteLogMessage struct {
	// log level
	Level AirbyteLogMessageLevel `json:"level" yaml:"level" mapstructure:"level"`

	// log message
	Message string `json:"message" yaml:"message" mapstructure:"message"`

	// an optional stack trace if the log message corresponds to an exception
	StackTrace *string `json:"stack_trace,omitempty" yaml:"stack_trace,omitempty" mapstructure:"stack_trace,omitempty"`

	AdditionalProperties interface{} `mapstructure:",remain"`
}

type AirbyteLogMessageLevel string

const AirbyteLogMessageLevelDEBUG AirbyteLogMessageLevel = "DEBUG"
const AirbyteLogMessageLevelERROR AirbyteLogMessageLevel = "ERROR"
const AirbyteLogMessageLevelFATAL AirbyteLogMessageLevel = "FATAL"
const AirbyteLogMessageLevelINFO AirbyteLogMessageLevel = "INFO"
const AirbyteLogMessageLevelTRACE AirbyteLogMessageLevel = "TRACE"
const AirbyteLogMessageLevelWARN AirbyteLogMessageLevel = "WARN"

var enumValues_AirbyteLogMessageLevel = []interface{}{
	"FATAL",
	"ERROR",
	"WARN",
	"INFO",
	"DEBUG",
	"TRACE",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *AirbyteLogMessageLevel) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_AirbyteLogMessageLevel {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_AirbyteLogMessageLevel, v)
	}
	*j = AirbyteLogMessageLevel(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *AirbyteLogMessage) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["level"]; raw != nil && !ok {
		return fmt.Errorf("field level in AirbyteLogMessage: required")
	}
	if _, ok := raw["message"]; raw != nil && !ok {
		return fmt.Errorf("field message in AirbyteLogMessage: required")
	}
	type Plain AirbyteLogMessage
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	st := reflect.TypeOf(Plain{})
	for i := range st.NumField() {
		delete(raw, st.Field(i).Name)
		delete(raw, strings.Split(st.Field(i).Tag.Get("json"), ",")[0])
	}
	if err := mapstructure.Decode(raw, &plain.AdditionalProperties); err != nil {
		return err
	}
	*j = AirbyteLogMessage(plain)
	return nil
}

type AirbyteMessage struct {
	// catalog message: the catalog
	Catalog *AirbyteCatalog `json:"catalog,omitempty" yaml:"catalog,omitempty" mapstructure:"catalog,omitempty"`

	// ConnectionStatus corresponds to the JSON schema field "connectionStatus".
	ConnectionStatus *AirbyteConnectionStatus `json:"connectionStatus,omitempty" yaml:"connectionStatus,omitempty" mapstructure:"connectionStatus,omitempty"`

	// connector config message: a message to communicate an updated configuration
	// from a connector that should be persisted
	Control *AirbyteControlMessage `json:"control,omitempty" yaml:"control,omitempty" mapstructure:"control,omitempty"`

	// destination catalog message: the catalog
	DestinationCatalog *DestinationCatalog `json:"destination_catalog,omitempty" yaml:"destination_catalog,omitempty" mapstructure:"destination_catalog,omitempty"`

	// log message: any kind of logging you want the platform to know about.
	Log *AirbyteLogMessage `json:"log,omitempty" yaml:"log,omitempty" mapstructure:"log,omitempty"`

	// record message: the record
	Record *AirbyteRecordMessage `json:"record,omitempty" yaml:"record,omitempty" mapstructure:"record,omitempty"`

	// Spec corresponds to the JSON schema field "spec".
	Spec *ConnectorSpecification `json:"spec,omitempty" yaml:"spec,omitempty" mapstructure:"spec,omitempty"`

	// schema message: the state. Must be the last message produced. The platform uses
	// this information
	State *AirbyteStateMessage `json:"state,omitempty" yaml:"state,omitempty" mapstructure:"state,omitempty"`

	// trace message: a message to communicate information about the status and
	// performance of a connector
	Trace *AirbyteTraceMessage `json:"trace,omitempty" yaml:"trace,omitempty" mapstructure:"trace,omitempty"`

	// Message type
	Type AirbyteMessageType `json:"type" yaml:"type" mapstructure:"type"`

	AdditionalProperties interface{} `mapstructure:",remain"`
}

type AirbyteMessageType string

const AirbyteMessageTypeCATALOG AirbyteMessageType = "CATALOG"
const AirbyteMessageTypeCONNECTIONSTATUS AirbyteMessageType = "CONNECTION_STATUS"
const AirbyteMessageTypeCONTROL AirbyteMessageType = "CONTROL"
const AirbyteMessageTypeDESTINATIONCATALOG AirbyteMessageType = "DESTINATION_CATALOG"
const AirbyteMessageTypeLOG AirbyteMessageType = "LOG"
const AirbyteMessageTypeRECORD AirbyteMessageType = "RECORD"
const AirbyteMessageTypeSPEC AirbyteMessageType = "SPEC"
const AirbyteMessageTypeSTATE AirbyteMessageType = "STATE"
const AirbyteMessageTypeTRACE AirbyteMessageType = "TRACE"

var enumValues_AirbyteMessageType = []interface{}{
	"RECORD",
	"STATE",
	"LOG",
	"SPEC",
	"CONNECTION_STATUS",
	"CATALOG",
	"TRACE",
	"CONTROL",
	"DESTINATION_CATALOG",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *AirbyteMessageType) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_AirbyteMessageType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_AirbyteMessageType, v)
	}
	*j = AirbyteMessageType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *AirbyteMessage) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in AirbyteMessage: required")
	}
	type Plain AirbyteMessage
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	st := reflect.TypeOf(Plain{})
	for i := range st.NumField() {
		delete(raw, st.Field(i).Name)
		delete(raw, strings.Split(st.Field(i).Tag.Get("json"), ",")[0])
	}
	if err := mapstructure.Decode(raw, &plain.AdditionalProperties); err != nil {
		return err
	}
	*j = AirbyteMessage(plain)
	return nil
}

// AirbyteProtocol structs
type AirbyteProtocolYaml struct {
	// AirbyteMessage corresponds to the JSON schema field "airbyte_message".
	AirbyteMessage *AirbyteMessage `json:"airbyte_message,omitempty" yaml:"airbyte_message,omitempty" mapstructure:"airbyte_message,omitempty"`

	// ConfiguredAirbyteCatalog corresponds to the JSON schema field
	// "configured_airbyte_catalog".
	ConfiguredAirbyteCatalog *ConfiguredAirbyteCatalog `json:"configured_airbyte_catalog,omitempty" yaml:"configured_airbyte_catalog,omitempty" mapstructure:"configured_airbyte_catalog,omitempty"`
}

type AirbyteRecordMessage struct {
	// record data
	Data map[string]interface{} `json:"data" yaml:"data" mapstructure:"data"`

	// when the data was emitted from the source. epoch in millisecond.
	EmittedAt int `json:"emitted_at" yaml:"emitted_at" mapstructure:"emitted_at"`

	// An internal facing reference to the file described by the record if applicable.
	FileReference *AirbyteRecordMessageFileReference `json:"file_reference,omitempty" yaml:"file_reference,omitempty" mapstructure:"file_reference,omitempty"`

	// Information about this record added mid-sync
	Meta *AirbyteRecordMessageMeta `json:"meta,omitempty" yaml:"meta,omitempty" mapstructure:"meta,omitempty"`

	// namespace the data is associated with
	Namespace *string `json:"namespace,omitempty" yaml:"namespace,omitempty" mapstructure:"namespace,omitempty"`

	// stream the data is associated with
	Stream string `json:"stream" yaml:"stream" mapstructure:"stream"`

	AdditionalProperties interface{} `mapstructure:",remain"`
}

type AirbyteRecordMessageFileReference struct {
	// The size of the referenced file in bytes.
	FileSizeBytes *int `json:"file_size_bytes,omitempty" yaml:"file_size_bytes,omitempty" mapstructure:"file_size_bytes,omitempty"`

	// The relative path to the referenced file in source.
	SourceFileRelativePath *string `json:"source_file_relative_path,omitempty" yaml:"source_file_relative_path,omitempty" mapstructure:"source_file_relative_path,omitempty"`

	// The absolute path to the referenced file in the staging area.
	StagingFileUrl *string `json:"staging_file_url,omitempty" yaml:"staging_file_url,omitempty" mapstructure:"staging_file_url,omitempty"`

	AdditionalProperties interface{} `mapstructure:",remain"`
}

type AirbyteRecordMessageMeta struct {
	// Lists of changes to the content of this record which occurred during syncing
	Changes []AirbyteRecordMessageMetaChange `json:"changes,omitempty" yaml:"changes,omitempty" mapstructure:"changes,omitempty"`

	AdditionalProperties interface{} `mapstructure:",remain"`
}

type AirbyteRecordMessageMetaChange struct {
	// The type of change that occurred
	Change AirbyteRecordMessageMetaChangeChange `json:"change" yaml:"change" mapstructure:"change"`

	// The field that had the change occur (required)
	Field string `json:"field" yaml:"field" mapstructure:"field"`

	// The reason that the change occurred
	Reason AirbyteRecordMessageMetaChangeReason `json:"reason" yaml:"reason" mapstructure:"reason"`

	AdditionalProperties interface{} `mapstructure:",remain"`
}

type AirbyteRecordMessageMetaChangeChange string

const AirbyteRecordMessageMetaChangeChangeNULLED AirbyteRecordMessageMetaChangeChange = "NULLED"
const AirbyteRecordMessageMetaChangeChangeTRUNCATED AirbyteRecordMessageMetaChangeChange = "TRUNCATED"

var enumValues_AirbyteRecordMessageMetaChangeChange = []interface{}{
	"NULLED",
	"TRUNCATED",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *AirbyteRecordMessageMetaChangeChange) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_AirbyteRecordMessageMetaChangeChange {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_AirbyteRecordMessageMetaChangeChange, v)
	}
	*j = AirbyteRecordMessageMetaChangeChange(v)
	return nil
}

type AirbyteRecordMessageMetaChangeReason string

const AirbyteRecordMessageMetaChangeReasonDESTINATIONFIELDSIZELIMITATION AirbyteRecordMessageMetaChangeReason = "DESTINATION_FIELD_SIZE_LIMITATION"
const AirbyteRecordMessageMetaChangeReasonDESTINATIONRECORDSIZELIMITATION AirbyteRecordMessageMetaChangeReason = "DESTINATION_RECORD_SIZE_LIMITATION"
const AirbyteRecordMessageMetaChangeReasonDESTINATIONSERIALIZATIONERROR AirbyteRecordMessageMetaChangeReason = "DESTINATION_SERIALIZATION_ERROR"
const AirbyteRecordMessageMetaChangeReasonDESTINATIONTYPECASTERROR AirbyteRecordMessageMetaChangeReason = "DESTINATION_TYPECAST_ERROR"
const AirbyteRecordMessageMetaChangeReasonPLATFORMFIELDSIZELIMITATION AirbyteRecordMessageMetaChangeReason = "PLATFORM_FIELD_SIZE_LIMITATION"
const AirbyteRecordMessageMetaChangeReasonPLATFORMRECORDSIZELIMITATION AirbyteRecordMessageMetaChangeReason = "PLATFORM_RECORD_SIZE_LIMITATION"
const AirbyteRecordMessageMetaChangeReasonPLATFORMSERIALIZATIONERROR AirbyteRecordMessageMetaChangeReason = "PLATFORM_SERIALIZATION_ERROR"
const AirbyteRecordMessageMetaChangeReasonSOURCEFIELDSIZELIMITATION AirbyteRecordMessageMetaChangeReason = "SOURCE_FIELD_SIZE_LIMITATION"
const AirbyteRecordMessageMetaChangeReasonSOURCERECORDSIZELIMITATION AirbyteRecordMessageMetaChangeReason = "SOURCE_RECORD_SIZE_LIMITATION"
const AirbyteRecordMessageMetaChangeReasonSOURCERETRIEVALERROR AirbyteRecordMessageMetaChangeReason = "SOURCE_RETRIEVAL_ERROR"
const AirbyteRecordMessageMetaChangeReasonSOURCESERIALIZATIONERROR AirbyteRecordMessageMetaChangeReason = "SOURCE_SERIALIZATION_ERROR"

var enumValues_AirbyteRecordMessageMetaChangeReason = []interface{}{
	"SOURCE_RECORD_SIZE_LIMITATION",
	"DESTINATION_RECORD_SIZE_LIMITATION",
	"PLATFORM_RECORD_SIZE_LIMITATION",
	"SOURCE_FIELD_SIZE_LIMITATION",
	"DESTINATION_FIELD_SIZE_LIMITATION",
	"PLATFORM_FIELD_SIZE_LIMITATION",
	"SOURCE_SERIALIZATION_ERROR",
	"DESTINATION_SERIALIZATION_ERROR",
	"PLATFORM_SERIALIZATION_ERROR",
	"SOURCE_RETRIEVAL_ERROR",
	"DESTINATION_TYPECAST_ERROR",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *AirbyteRecordMessageMetaChangeReason) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_AirbyteRecordMessageMetaChangeReason {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_AirbyteRecordMessageMetaChangeReason, v)
	}
	*j = AirbyteRecordMessageMetaChangeReason(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *AirbyteRecordMessageMetaChange) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["change"]; raw != nil && !ok {
		return fmt.Errorf("field change in AirbyteRecordMessageMetaChange: required")
	}
	if _, ok := raw["field"]; raw != nil && !ok {
		return fmt.Errorf("field field in AirbyteRecordMessageMetaChange: required")
	}
	if _, ok := raw["reason"]; raw != nil && !ok {
		return fmt.Errorf("field reason in AirbyteRecordMessageMetaChange: required")
	}
	type Plain AirbyteRecordMessageMetaChange
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	st := reflect.TypeOf(Plain{})
	for i := range st.NumField() {
		delete(raw, st.Field(i).Name)
		delete(raw, strings.Split(st.Field(i).Tag.Get("json"), ",")[0])
	}
	if err := mapstructure.Decode(raw, &plain.AdditionalProperties); err != nil {
		return err
	}
	*j = AirbyteRecordMessageMetaChange(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *AirbyteRecordMessage) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["data"]; raw != nil && !ok {
		return fmt.Errorf("field data in AirbyteRecordMessage: required")
	}
	if _, ok := raw["emitted_at"]; raw != nil && !ok {
		return fmt.Errorf("field emitted_at in AirbyteRecordMessage: required")
	}
	if _, ok := raw["stream"]; raw != nil && !ok {
		return fmt.Errorf("field stream in AirbyteRecordMessage: required")
	}
	type Plain AirbyteRecordMessage
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	st := reflect.TypeOf(Plain{})
	for i := range st.NumField() {
		delete(raw, st.Field(i).Name)
		delete(raw, strings.Split(st.Field(i).Tag.Get("json"), ",")[0])
	}
	if err := mapstructure.Decode(raw, &plain.AdditionalProperties); err != nil {
		return err
	}
	*j = AirbyteRecordMessage(plain)
	return nil
}

type AirbyteStateMessage struct {
	// (Deprecated) the state data
	Data map[string]interface{} `json:"data,omitempty" yaml:"data,omitempty" mapstructure:"data,omitempty"`

	// DestinationStats corresponds to the JSON schema field "destinationStats".
	DestinationStats *AirbyteStateStats `json:"destinationStats,omitempty" yaml:"destinationStats,omitempty" mapstructure:"destinationStats,omitempty"`

	// Global corresponds to the JSON schema field "global".
	Global *AirbyteGlobalState `json:"global,omitempty" yaml:"global,omitempty" mapstructure:"global,omitempty"`

	// SourceStats corresponds to the JSON schema field "sourceStats".
	SourceStats *AirbyteStateStats `json:"sourceStats,omitempty" yaml:"sourceStats,omitempty" mapstructure:"sourceStats,omitempty"`

	// Stream corresponds to the JSON schema field "stream".
	Stream *AirbyteStreamState `json:"stream,omitempty" yaml:"stream,omitempty" mapstructure:"stream,omitempty"`

	// Type corresponds to the JSON schema field "type".
	Type *AirbyteStateType `json:"type,omitempty" yaml:"type,omitempty" mapstructure:"type,omitempty"`

	AdditionalProperties interface{} `mapstructure:",remain"`
}

type AirbyteStateStats struct {
	// the number of records which were emitted for this state message, for this
	// stream or global. While the value should always be a round number, it is
	// defined as a double to account for integer overflows, and the value should
	// always have a decimal point for proper serialization.
	RecordCount *float64 `json:"recordCount,omitempty" yaml:"recordCount,omitempty" mapstructure:"recordCount,omitempty"`

	// the number of records which were rejected for this state message, for this
	// stream or global. While the value should always be a round number, it is
	// defined as a double to account for integer overflows, and the value should
	// always have a decimal point for proper serialization.
	//
	RejectedRecordCount *float64 `json:"rejectedRecordCount,omitempty" yaml:"rejectedRecordCount,omitempty" mapstructure:"rejectedRecordCount,omitempty"`

	AdditionalProperties interface{} `mapstructure:",remain"`
}

type AirbyteStateType string

const AirbyteStateTypeGLOBAL AirbyteStateType = "GLOBAL"
const AirbyteStateTypeLEGACY AirbyteStateType = "LEGACY"
const AirbyteStateTypeSTREAM AirbyteStateType = "STREAM"

var enumValues_AirbyteStateType = []interface{}{
	"GLOBAL",
	"STREAM",
	"LEGACY",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *AirbyteStateType) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_AirbyteStateType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_AirbyteStateType, v)
	}
	*j = AirbyteStateType(v)
	return nil
}

type AirbyteStream struct {
	// Path to the field that will be used to determine if a record is new or modified
	// since the last sync. If not provided by the source, the end user will have to
	// specify the comparable themselves.
	DefaultCursorField []string `json:"default_cursor_field,omitempty" yaml:"default_cursor_field,omitempty" mapstructure:"default_cursor_field,omitempty"`

	// This stream describes a stream of files and their metadata.
	IsFileBased *bool `json:"is_file_based,omitempty" yaml:"is_file_based,omitempty" mapstructure:"is_file_based,omitempty"`

	// If the stream is resumable or not. Should be set to true if the stream supports
	// incremental. Defaults to false.
	// Primarily used by the Platform in Full Refresh to determine if a Full Refresh
	// stream should actually be treated as incremental within a job.
	IsResumable *bool `json:"is_resumable,omitempty" yaml:"is_resumable,omitempty" mapstructure:"is_resumable,omitempty"`

	// Stream schema using Json Schema specs.
	JsonSchema map[string]interface{} `json:"json_schema" yaml:"json_schema" mapstructure:"json_schema"`

	// Stream's name.
	Name string `json:"name" yaml:"name" mapstructure:"name"`

	// Optional Source-defined namespace. Currently only used by JDBC destinations to
	// determine what schema to write to. Airbyte streams from the same sources should
	// have the same namespace.
	Namespace *string `json:"namespace,omitempty" yaml:"namespace,omitempty" mapstructure:"namespace,omitempty"`

	// If the source defines the cursor field, then any other cursor field inputs will
	// be ignored. If it does not,
	// either the user_provided one is used, or the default one is used as a backup.
	// This field must be set if
	// is_resumable is set to true, including resumable full refresh synthetic
	// cursors.
	SourceDefinedCursor *bool `json:"source_defined_cursor,omitempty" yaml:"source_defined_cursor,omitempty" mapstructure:"source_defined_cursor,omitempty"`

	// If the source defines the primary key, paths to the fields that will be used as
	// a primary key. If not provided by the source, the end user will have to specify
	// the primary key themselves.
	SourceDefinedPrimaryKey [][]string `json:"source_defined_primary_key,omitempty" yaml:"source_defined_primary_key,omitempty" mapstructure:"source_defined_primary_key,omitempty"`

	// List of sync modes supported by this stream.
	SupportedSyncModes []SyncMode `json:"supported_sync_modes" yaml:"supported_sync_modes" mapstructure:"supported_sync_modes"`

	AdditionalProperties interface{} `mapstructure:",remain"`
}

type AirbyteStreamState struct {
	// StreamDescriptor corresponds to the JSON schema field "stream_descriptor".
	StreamDescriptor StreamDescriptor `json:"stream_descriptor" yaml:"stream_descriptor" mapstructure:"stream_descriptor"`

	// StreamState corresponds to the JSON schema field "stream_state".
	StreamState map[string]interface{} `json:"stream_state,omitempty" yaml:"stream_state,omitempty" mapstructure:"stream_state,omitempty"`

	AdditionalProperties interface{} `mapstructure:",remain"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *AirbyteStreamState) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["stream_descriptor"]; raw != nil && !ok {
		return fmt.Errorf("field stream_descriptor in AirbyteStreamState: required")
	}
	type Plain AirbyteStreamState
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	st := reflect.TypeOf(Plain{})
	for i := range st.NumField() {
		delete(raw, st.Field(i).Name)
		delete(raw, strings.Split(st.Field(i).Tag.Get("json"), ",")[0])
	}
	if err := mapstructure.Decode(raw, &plain.AdditionalProperties); err != nil {
		return err
	}
	*j = AirbyteStreamState(plain)
	return nil
}

type AirbyteStreamStatus string

const AirbyteStreamStatusCOMPLETE AirbyteStreamStatus = "COMPLETE"
const AirbyteStreamStatusINCOMPLETE AirbyteStreamStatus = "INCOMPLETE"
const AirbyteStreamStatusRUNNING AirbyteStreamStatus = "RUNNING"

// Rate Limited Information
type AirbyteStreamStatusRateLimitedReason struct {
	// Optional time in ms representing when the API quota is going to be reset
	QuotaReset *int `json:"quota_reset,omitempty" yaml:"quota_reset,omitempty" mapstructure:"quota_reset,omitempty"`
}

// The reason associated with the status of the stream.
type AirbyteStreamStatusReason struct {
	// RateLimited corresponds to the JSON schema field "rate_limited".
	RateLimited *AirbyteStreamStatusRateLimitedReason `json:"rate_limited,omitempty" yaml:"rate_limited,omitempty" mapstructure:"rate_limited,omitempty"`

	// Type corresponds to the JSON schema field "type".
	Type AirbyteStreamStatusReasonType `json:"type" yaml:"type" mapstructure:"type"`
}

type AirbyteStreamStatusReasonType string

const AirbyteStreamStatusReasonTypeRATELIMITED AirbyteStreamStatusReasonType = "RATE_LIMITED"

var enumValues_AirbyteStreamStatusReasonType = []interface{}{
	"RATE_LIMITED",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *AirbyteStreamStatusReasonType) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_AirbyteStreamStatusReasonType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_AirbyteStreamStatusReasonType, v)
	}
	*j = AirbyteStreamStatusReasonType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *AirbyteStreamStatusReason) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in AirbyteStreamStatusReason: required")
	}
	type Plain AirbyteStreamStatusReason
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = AirbyteStreamStatusReason(plain)
	return nil
}

const AirbyteStreamStatusSTARTED AirbyteStreamStatus = "STARTED"

type AirbyteStreamStatusTraceMessage struct {
	// The reasons associated with the status of the stream
	Reasons []AirbyteStreamStatusReason `json:"reasons,omitempty" yaml:"reasons,omitempty" mapstructure:"reasons,omitempty"`

	// The current status of the stream
	Status AirbyteStreamStatus `json:"status" yaml:"status" mapstructure:"status"`

	// The stream associated with the status
	StreamDescriptor StreamDescriptor `json:"stream_descriptor" yaml:"stream_descriptor" mapstructure:"stream_descriptor"`

	AdditionalProperties interface{} `mapstructure:",remain"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *AirbyteStreamStatusTraceMessage) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["status"]; raw != nil && !ok {
		return fmt.Errorf("field status in AirbyteStreamStatusTraceMessage: required")
	}
	if _, ok := raw["stream_descriptor"]; raw != nil && !ok {
		return fmt.Errorf("field stream_descriptor in AirbyteStreamStatusTraceMessage: required")
	}
	type Plain AirbyteStreamStatusTraceMessage
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	st := reflect.TypeOf(Plain{})
	for i := range st.NumField() {
		delete(raw, st.Field(i).Name)
		delete(raw, strings.Split(st.Field(i).Tag.Get("json"), ",")[0])
	}
	if err := mapstructure.Decode(raw, &plain.AdditionalProperties); err != nil {
		return err
	}
	*j = AirbyteStreamStatusTraceMessage(plain)
	return nil
}

var enumValues_AirbyteStreamStatus = []interface{}{
	"STARTED",
	"RUNNING",
	"COMPLETE",
	"INCOMPLETE",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *AirbyteStreamStatus) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_AirbyteStreamStatus {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_AirbyteStreamStatus, v)
	}
	*j = AirbyteStreamStatus(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *AirbyteStream) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["json_schema"]; raw != nil && !ok {
		return fmt.Errorf("field json_schema in AirbyteStream: required")
	}
	if _, ok := raw["name"]; raw != nil && !ok {
		return fmt.Errorf("field name in AirbyteStream: required")
	}
	if _, ok := raw["supported_sync_modes"]; raw != nil && !ok {
		return fmt.Errorf("field supported_sync_modes in AirbyteStream: required")
	}
	type Plain AirbyteStream
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.SupportedSyncModes != nil && len(plain.SupportedSyncModes) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "supported_sync_modes", 1)
	}
	st := reflect.TypeOf(Plain{})
	for i := range st.NumField() {
		delete(raw, st.Field(i).Name)
		delete(raw, strings.Split(st.Field(i).Tag.Get("json"), ",")[0])
	}
	if err := mapstructure.Decode(raw, &plain.AdditionalProperties); err != nil {
		return err
	}
	*j = AirbyteStream(plain)
	return nil
}

type AirbyteTraceMessage struct {
	// Analytics corresponds to the JSON schema field "analytics".
	Analytics *AirbyteAnalyticsTraceMessage `json:"analytics,omitempty" yaml:"analytics,omitempty" mapstructure:"analytics,omitempty"`

	// the time in ms that the message was emitted
	EmittedAt float64 `json:"emitted_at" yaml:"emitted_at" mapstructure:"emitted_at"`

	// error trace message: the error object
	Error *AirbyteErrorTraceMessage `json:"error,omitempty" yaml:"error,omitempty" mapstructure:"error,omitempty"`

	// Estimate trace message: a guess at how much data will be produced in this sync
	Estimate *AirbyteEstimateTraceMessage `json:"estimate,omitempty" yaml:"estimate,omitempty" mapstructure:"estimate,omitempty"`

	// Stream status trace message:  the current status of a stream within a source
	StreamStatus *AirbyteStreamStatusTraceMessage `json:"stream_status,omitempty" yaml:"stream_status,omitempty" mapstructure:"stream_status,omitempty"`

	// the type of trace message
	Type AirbyteTraceMessageType `json:"type" yaml:"type" mapstructure:"type"`

	AdditionalProperties interface{} `mapstructure:",remain"`
}

type AirbyteTraceMessageType string

const AirbyteTraceMessageTypeANALYTICS AirbyteTraceMessageType = "ANALYTICS"
const AirbyteTraceMessageTypeERROR AirbyteTraceMessageType = "ERROR"
const AirbyteTraceMessageTypeESTIMATE AirbyteTraceMessageType = "ESTIMATE"
const AirbyteTraceMessageTypeSTREAMSTATUS AirbyteTraceMessageType = "STREAM_STATUS"

var enumValues_AirbyteTraceMessageType = []interface{}{
	"ERROR",
	"ESTIMATE",
	"STREAM_STATUS",
	"ANALYTICS",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *AirbyteTraceMessageType) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_AirbyteTraceMessageType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_AirbyteTraceMessageType, v)
	}
	*j = AirbyteTraceMessageType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *AirbyteTraceMessage) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["emitted_at"]; raw != nil && !ok {
		return fmt.Errorf("field emitted_at in AirbyteTraceMessage: required")
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in AirbyteTraceMessage: required")
	}
	type Plain AirbyteTraceMessage
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	st := reflect.TypeOf(Plain{})
	for i := range st.NumField() {
		delete(raw, st.Field(i).Name)
		delete(raw, strings.Split(st.Field(i).Tag.Get("json"), ",")[0])
	}
	if err := mapstructure.Decode(raw, &plain.AdditionalProperties); err != nil {
		return err
	}
	*j = AirbyteTraceMessage(plain)
	return nil
}

// Airbyte stream schema catalog
type ConfiguredAirbyteCatalog struct {
	// Streams corresponds to the JSON schema field "streams".
	Streams []ConfiguredAirbyteStream `json:"streams" yaml:"streams" mapstructure:"streams"`

	AdditionalProperties interface{} `mapstructure:",remain"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ConfiguredAirbyteCatalog) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["streams"]; raw != nil && !ok {
		return fmt.Errorf("field streams in ConfiguredAirbyteCatalog: required")
	}
	type Plain ConfiguredAirbyteCatalog
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	st := reflect.TypeOf(Plain{})
	for i := range st.NumField() {
		delete(raw, st.Field(i).Name)
		delete(raw, strings.Split(st.Field(i).Tag.Get("json"), ",")[0])
	}
	if err := mapstructure.Decode(raw, &plain.AdditionalProperties); err != nil {
		return err
	}
	*j = ConfiguredAirbyteCatalog(plain)
	return nil
}

type ConfiguredAirbyteStream struct {
	// Path to the field that will be used to determine if a record is new or modified
	// since the last sync. This field is REQUIRED if `sync_mode` is `incremental`.
	// Otherwise it is ignored.
	CursorField []string `json:"cursor_field,omitempty" yaml:"cursor_field,omitempty" mapstructure:"cursor_field,omitempty"`

	// DestinationObjectName corresponds to the JSON schema field
	// "destination_object_name".
	DestinationObjectName *string `json:"destination_object_name,omitempty" yaml:"destination_object_name,omitempty" mapstructure:"destination_object_name,omitempty"`

	// DestinationSyncMode corresponds to the JSON schema field
	// "destination_sync_mode".
	DestinationSyncMode DestinationSyncMode `json:"destination_sync_mode" yaml:"destination_sync_mode" mapstructure:"destination_sync_mode"`

	// Monotically increasing numeric id representing the current generation of a
	// stream. This id can be shared across syncs.
	// If this is null, it means that the platform is not supporting the refresh and
	// it is expected that no extra id will be added to the records and no data from
	// previous generation will be cleanup.
	GenerationId *int `json:"generation_id,omitempty" yaml:"generation_id,omitempty" mapstructure:"generation_id,omitempty"`

	// If the stream is_file_based, determines whether to include the associated files
	// in the sync. Otherwise, this property will be ignored.
	IncludeFiles *bool `json:"include_files,omitempty" yaml:"include_files,omitempty" mapstructure:"include_files,omitempty"`

	// The minimum generation id which is needed in a stream. If it is present, the
	// destination will try to delete the data that are part of a generation lower
	// than this property. If the minimum generation is equals to 0, no data deletion
	// is expected from the destiantion
	// If this is null, it means that the platform is not supporting the refresh and
	// it is expected that no extra id will be added to the records and no data from
	// previous generation will be cleanup.
	MinimumGenerationId *int `json:"minimum_generation_id,omitempty" yaml:"minimum_generation_id,omitempty" mapstructure:"minimum_generation_id,omitempty"`

	// Paths to the fields that will be used as primary key. This field is REQUIRED if
	// `destination_sync_mode` is `*_dedup`. Otherwise it is ignored.
	PrimaryKey [][]string `json:"primary_key,omitempty" yaml:"primary_key,omitempty" mapstructure:"primary_key,omitempty"`

	// Stream corresponds to the JSON schema field "stream".
	Stream AirbyteStream `json:"stream" yaml:"stream" mapstructure:"stream"`

	// Monotically increasing numeric id representing the current sync id. This is
	// aimed to be unique per sync.
	// If this is null, it means that the platform is not supporting the refresh and
	// it is expected that no extra id will be added to the records and no data from
	// previous generation will be cleanup.
	SyncId *int `json:"sync_id,omitempty" yaml:"sync_id,omitempty" mapstructure:"sync_id,omitempty"`

	// SyncMode corresponds to the JSON schema field "sync_mode".
	SyncMode SyncMode `json:"sync_mode" yaml:"sync_mode" mapstructure:"sync_mode"`

	AdditionalProperties interface{} `mapstructure:",remain"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ConfiguredAirbyteStream) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["stream"]; raw != nil && !ok {
		return fmt.Errorf("field stream in ConfiguredAirbyteStream: required")
	}
	type Plain ConfiguredAirbyteStream
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if v, ok := raw["destination_sync_mode"]; !ok || v == nil {
		plain.DestinationSyncMode = "append"
	}
	if v, ok := raw["sync_mode"]; !ok || v == nil {
		plain.SyncMode = "full_refresh"
	}
	st := reflect.TypeOf(Plain{})
	for i := range st.NumField() {
		delete(raw, st.Field(i).Name)
		delete(raw, strings.Split(st.Field(i).Tag.Get("json"), ",")[0])
	}
	if err := mapstructure.Decode(raw, &plain.AdditionalProperties); err != nil {
		return err
	}
	*j = ConfiguredAirbyteStream(plain)
	return nil
}

// Specification of a connector (source/destination)
type ConnectorSpecification struct {
	// Additional and optional specification object to describe what an 'advanced'
	// Auth flow would need to function.
	//   - A connector should be able to fully function with the configuration as
	// described by the ConnectorSpecification in a 'basic' mode.
	//   - The 'advanced' mode provides easier UX for the user with UI improvements
	// and automations. However, this requires further setup on the
	//   server side by instance or workspace admins beforehand. The trade-off is that
	// the user does not have to provide as many technical
	//   inputs anymore and the auth process is faster and easier to complete.
	AdvancedAuth *ConnectorSpecificationAdvancedAuth `json:"advanced_auth,omitempty" yaml:"advanced_auth,omitempty" mapstructure:"advanced_auth,omitempty"`

	// deprecated, switching to advanced_auth instead
	AuthSpecification *ConnectorSpecificationAuthSpecification `json:"authSpecification,omitempty" yaml:"authSpecification,omitempty" mapstructure:"authSpecification,omitempty"`

	// ChangelogUrl corresponds to the JSON schema field "changelogUrl".
	ChangelogUrl *string `json:"changelogUrl,omitempty" yaml:"changelogUrl,omitempty" mapstructure:"changelogUrl,omitempty"`

	// ConnectorDefinition specific blob. Must be a valid JSON string.
	ConnectionSpecification map[string]interface{} `json:"connectionSpecification" yaml:"connectionSpecification" mapstructure:"connectionSpecification"`

	// DocumentationUrl corresponds to the JSON schema field "documentationUrl".
	DocumentationUrl *string `json:"documentationUrl,omitempty" yaml:"documentationUrl,omitempty" mapstructure:"documentationUrl,omitempty"`

	// the Airbyte Protocol version supported by the connector. Protocol versioning
	// uses SemVer.
	ProtocolVersion *string `json:"protocol_version,omitempty" yaml:"protocol_version,omitempty" mapstructure:"protocol_version,omitempty"`

	// List of destination sync modes supported by the connector
	SupportedDestinationSyncModes []DestinationSyncMode `json:"supported_destination_sync_modes,omitempty" yaml:"supported_destination_sync_modes,omitempty" mapstructure:"supported_destination_sync_modes,omitempty"`

	// If the connector supports DBT or not.
	SupportsDBT bool `json:"supportsDBT,omitempty" yaml:"supportsDBT,omitempty" mapstructure:"supportsDBT,omitempty"`

	// (deprecated) If the connector supports incremental mode or not.
	SupportsIncremental *bool `json:"supportsIncremental,omitempty" yaml:"supportsIncremental,omitempty" mapstructure:"supportsIncremental,omitempty"`

	// If the connector supports normalization or not.
	SupportsNormalization bool `json:"supportsNormalization,omitempty" yaml:"supportsNormalization,omitempty" mapstructure:"supportsNormalization,omitempty"`

	AdditionalProperties interface{} `mapstructure:",remain"`
}

// Additional and optional specification object to describe what an 'advanced' Auth
// flow would need to function.
//   - A connector should be able to fully function with the configuration as
//
// described by the ConnectorSpecification in a 'basic' mode.
//   - The 'advanced' mode provides easier UX for the user with UI improvements and
//
// automations. However, this requires further setup on the
//
//	server side by instance or workspace admins beforehand. The trade-off is that
//
// the user does not have to provide as many technical
//
//	inputs anymore and the auth process is faster and easier to complete.
type ConnectorSpecificationAdvancedAuth struct {
	// AuthFlowType corresponds to the JSON schema field "auth_flow_type".
	AuthFlowType *ConnectorSpecificationAdvancedAuthAuthFlowType `json:"auth_flow_type,omitempty" yaml:"auth_flow_type,omitempty" mapstructure:"auth_flow_type,omitempty"`

	// OauthConfigSpecification corresponds to the JSON schema field
	// "oauth_config_specification".
	OauthConfigSpecification *OAuthConfigSpecification `json:"oauth_config_specification,omitempty" yaml:"oauth_config_specification,omitempty" mapstructure:"oauth_config_specification,omitempty"`

	// Json Path to a field in the connectorSpecification that should exist for the
	// advanced auth to be applicable.
	PredicateKey []string `json:"predicate_key,omitempty" yaml:"predicate_key,omitempty" mapstructure:"predicate_key,omitempty"`

	// Value of the predicate_key fields for the advanced auth to be applicable.
	PredicateValue *string `json:"predicate_value,omitempty" yaml:"predicate_value,omitempty" mapstructure:"predicate_value,omitempty"`
}

type ConnectorSpecificationAdvancedAuthAuthFlowType string

const ConnectorSpecificationAdvancedAuthAuthFlowTypeOauth10 ConnectorSpecificationAdvancedAuthAuthFlowType = "oauth1.0"
const ConnectorSpecificationAdvancedAuthAuthFlowTypeOauth20 ConnectorSpecificationAdvancedAuthAuthFlowType = "oauth2.0"

var enumValues_ConnectorSpecificationAdvancedAuthAuthFlowType = []interface{}{
	"oauth2.0",
	"oauth1.0",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ConnectorSpecificationAdvancedAuthAuthFlowType) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_ConnectorSpecificationAdvancedAuthAuthFlowType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_ConnectorSpecificationAdvancedAuthAuthFlowType, v)
	}
	*j = ConnectorSpecificationAdvancedAuthAuthFlowType(v)
	return nil
}

// deprecated, switching to advanced_auth instead
type ConnectorSpecificationAuthSpecification struct {
	// AuthType corresponds to the JSON schema field "auth_type".
	AuthType *ConnectorSpecificationAuthSpecificationAuthType `json:"auth_type,omitempty" yaml:"auth_type,omitempty" mapstructure:"auth_type,omitempty"`

	// If the connector supports OAuth, this field should be non-null.
	Oauth2Specification *OAuth2Specification `json:"oauth2Specification,omitempty" yaml:"oauth2Specification,omitempty" mapstructure:"oauth2Specification,omitempty"`
}

type ConnectorSpecificationAuthSpecificationAuthType string

const ConnectorSpecificationAuthSpecificationAuthTypeOauth20 ConnectorSpecificationAuthSpecificationAuthType = "oauth2.0"

var enumValues_ConnectorSpecificationAuthSpecificationAuthType = []interface{}{
	"oauth2.0",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ConnectorSpecificationAuthSpecificationAuthType) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_ConnectorSpecificationAuthSpecificationAuthType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_ConnectorSpecificationAuthSpecificationAuthType, v)
	}
	*j = ConnectorSpecificationAuthSpecificationAuthType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ConnectorSpecification) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["connectionSpecification"]; raw != nil && !ok {
		return fmt.Errorf("field connectionSpecification in ConnectorSpecification: required")
	}
	type Plain ConnectorSpecification
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if v, ok := raw["supportsDBT"]; !ok || v == nil {
		plain.SupportsDBT = false
	}
	if v, ok := raw["supportsNormalization"]; !ok || v == nil {
		plain.SupportsNormalization = false
	}
	st := reflect.TypeOf(Plain{})
	for i := range st.NumField() {
		delete(raw, st.Field(i).Name)
		delete(raw, strings.Split(st.Field(i).Tag.Get("json"), ",")[0])
	}
	if err := mapstructure.Decode(raw, &plain.AdditionalProperties); err != nil {
		return err
	}
	*j = ConnectorSpecification(plain)
	return nil
}

// Catalog for a destination
type DestinationCatalog struct {
	// An array of operations that can be performed on destination objects.
	Operations []DestinationOperation `json:"operations" yaml:"operations" mapstructure:"operations"`

	AdditionalProperties interface{} `mapstructure:",remain"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *DestinationCatalog) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["operations"]; raw != nil && !ok {
		return fmt.Errorf("field operations in DestinationCatalog: required")
	}
	type Plain DestinationCatalog
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	st := reflect.TypeOf(Plain{})
	for i := range st.NumField() {
		delete(raw, st.Field(i).Name)
		delete(raw, strings.Split(st.Field(i).Tag.Get("json"), ",")[0])
	}
	if err := mapstructure.Decode(raw, &plain.AdditionalProperties); err != nil {
		return err
	}
	*j = DestinationCatalog(plain)
	return nil
}

// A possible operation on a destination object.
type DestinationOperation struct {
	// Stream schema using Json Schema specs.
	JsonSchema map[string]interface{} `json:"json_schema" yaml:"json_schema" mapstructure:"json_schema"`

	// A list of keys that can be used to match a record in the destination object.
	// The inner array of strings represents a nested object path.
	MatchingKeys [][]string `json:"matching_keys,omitempty" yaml:"matching_keys,omitempty" mapstructure:"matching_keys,omitempty"`

	// The name of the destination object.
	ObjectName string `json:"object_name" yaml:"object_name" mapstructure:"object_name"`

	// The sync mode to be performed on the destination object.
	SyncMode DestinationSyncMode `json:"sync_mode" yaml:"sync_mode" mapstructure:"sync_mode"`

	AdditionalProperties interface{} `mapstructure:",remain"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *DestinationOperation) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["json_schema"]; raw != nil && !ok {
		return fmt.Errorf("field json_schema in DestinationOperation: required")
	}
	if _, ok := raw["object_name"]; raw != nil && !ok {
		return fmt.Errorf("field object_name in DestinationOperation: required")
	}
	if _, ok := raw["sync_mode"]; raw != nil && !ok {
		return fmt.Errorf("field sync_mode in DestinationOperation: required")
	}
	type Plain DestinationOperation
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	st := reflect.TypeOf(Plain{})
	for i := range st.NumField() {
		delete(raw, st.Field(i).Name)
		delete(raw, strings.Split(st.Field(i).Tag.Get("json"), ",")[0])
	}
	if err := mapstructure.Decode(raw, &plain.AdditionalProperties); err != nil {
		return err
	}
	*j = DestinationOperation(plain)
	return nil
}

type DestinationSyncMode string

const DestinationSyncModeAppend DestinationSyncMode = "append"
const DestinationSyncModeAppendDedup DestinationSyncMode = "append_dedup"
const DestinationSyncModeOverwrite DestinationSyncMode = "overwrite"
const DestinationSyncModeSoftDelete DestinationSyncMode = "soft_delete"
const DestinationSyncModeUpdate DestinationSyncMode = "update"

var enumValues_DestinationSyncMode = []interface{}{
	"append",
	"overwrite",
	"append_dedup",
	"update",
	"soft_delete",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *DestinationSyncMode) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_DestinationSyncMode {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_DestinationSyncMode, v)
	}
	*j = DestinationSyncMode(v)
	return nil
}

// An object containing any metadata needed to describe this connector's Oauth
// flow. Deprecated, switching to advanced_auth instead
type OAuth2Specification struct {
	// Pointers to the fields in the rootObject needed to obtain the initial
	// refresh/access tokens for the OAuth flow. Each inner array represents the path
	// in the rootObject of the referenced field. For example. Assume the rootObject
	// contains params 'app_secret', 'app_id' which are needed to get the initial
	// refresh token. If they are not nested in the rootObject, then the array would
	// look like this [['app_secret'], ['app_id']] If they are nested inside an object
	// called 'auth_params' then this array would be [['auth_params', 'app_secret'],
	// ['auth_params', 'app_id']]
	OauthFlowInitParameters [][]string `json:"oauthFlowInitParameters,omitempty" yaml:"oauthFlowInitParameters,omitempty" mapstructure:"oauthFlowInitParameters,omitempty"`

	// Pointers to the fields in the rootObject which can be populated from
	// successfully completing the oauth flow using the init parameters. This is
	// typically a refresh/access token. Each inner array represents the path in the
	// rootObject of the referenced field.
	OauthFlowOutputParameters [][]string `json:"oauthFlowOutputParameters,omitempty" yaml:"oauthFlowOutputParameters,omitempty" mapstructure:"oauthFlowOutputParameters,omitempty"`

	// A list of strings representing a pointer to the root object which contains any
	// oauth parameters in the ConnectorSpecification. Examples: if oauth parameters
	// were contained inside the top level, rootObject=[] If they were nested inside
	// another object {'credentials': {'app_id' etc...}, rootObject=['credentials'] If
	// they were inside a oneOf {'switch': {oneOf: [{client_id...},
	// {non_oauth_param]}},  rootObject=['switch', 0]
	RootObject []interface{} `json:"rootObject,omitempty" yaml:"rootObject,omitempty" mapstructure:"rootObject,omitempty"`

	AdditionalProperties interface{} `mapstructure:",remain"`
}

type OAuthConfigSpecification struct {
	// OAuth specific blob. This is a Json Schema used to validate Json configurations
	// produced by the OAuth flows as they are
	// returned by the distant OAuth APIs.
	// Must be a valid JSON describing the fields to merge back to
	// `ConnectorSpecification.connectionSpecification`.
	// For each field, a special annotation `path_in_connector_config` can be
	// specified to determine where to merge it,
	//
	// Examples:
	//     With a `refresh_token` in the `oauth response`:
	//
	//     complete_oauth_output_specification={
	//       refresh_token: {
	//         type: string,
	//         path_in_connector_config: ['credentials', 'refresh_token'],
	//         path_in_oauth_response: ['refresh_token']
	//       }
	//     }
	//
	//     With a nested `refresh_token` under the `data` object, in the `oauth
	// response`:
	//
	//     complete_oauth_output_specification={
	//       refresh_token: {
	//         type: string,
	//         path_in_connector_config: ['credentials', 'refresh_token'],
	//         path_in_oauth_response: ['data', 'refresh_token']
	//       }
	//     }
	CompleteOauthOutputSpecification map[string]interface{} `json:"complete_oauth_output_specification,omitempty" yaml:"complete_oauth_output_specification,omitempty" mapstructure:"complete_oauth_output_specification,omitempty"`

	// OAuth specific blob. This is a Json Schema used to validate Json configurations
	// persisted as Airbyte Server configurations.
	// Must be a valid non-nested JSON describing additional fields configured by the
	// Airbyte Instance or Workspace Admins to be used by the
	// server when completing an OAuth flow (typically exchanging an auth code for
	// refresh token).
	//
	// Examples:
	//
	//     complete_oauth_server_input_specification={
	//       client_id: {
	//         type: string
	//       },
	//       client_secret: {
	//         type: string
	//       }
	//     }
	CompleteOauthServerInputSpecification map[string]interface{} `json:"complete_oauth_server_input_specification,omitempty" yaml:"complete_oauth_server_input_specification,omitempty" mapstructure:"complete_oauth_server_input_specification,omitempty"`

	// OAuth specific blob. This is a Json Schema used to validate Json configurations
	// persisted as Airbyte Server configurations that
	// also need to be merged back into the connector configuration at runtime.
	// This is a subset configuration of `complete_oauth_server_input_specification`
	// that filters fields out to retain only the ones that
	// are necessary for the connector to function with OAuth. (some fields could be
	// used during oauth flows but not needed afterwards, therefore
	// they would be listed in the `complete_oauth_server_input_specification` but not
	// `complete_oauth_server_output_specification`)
	// Must be a valid non-nested JSON describing additional fields configured by the
	// Airbyte Instance or Workspace Admins to be used by the
	// connector when using OAuth flow APIs.
	// These fields are to be merged back to
	// `ConnectorSpecification.connectionSpecification`.
	// For each field, a special annotation `path_in_connector_config` can be
	// specified to determine where to merge it,
	//
	// Examples:
	//
	//       complete_oauth_server_output_specification={
	//         client_id: {
	//           type: string,
	//           path_in_connector_config: ['credentials', 'client_id']
	//         },
	//         client_secret: {
	//           type: string,
	//           path_in_connector_config: ['credentials', 'client_secret']
	//         }
	//       }
	CompleteOauthServerOutputSpecification map[string]interface{} `json:"complete_oauth_server_output_specification,omitempty" yaml:"complete_oauth_server_output_specification,omitempty" mapstructure:"complete_oauth_server_output_specification,omitempty"`

	// OAuth specific blob. Pertains to the fields defined by the connector relating
	// to the OAuth flow.
	OauthConnectorInputSpecification *OAuthConfigSpecificationOauthConnectorInputSpecification `json:"oauth_connector_input_specification,omitempty" yaml:"oauth_connector_input_specification,omitempty" mapstructure:"oauth_connector_input_specification,omitempty"`

	// OAuth specific blob. This is a Json Schema used to validate Json configurations
	// used as input to OAuth.
	// Must be a valid non-nested JSON that refers to properties from
	// ConnectorSpecification.connectionSpecification
	// using special annotation 'path_in_connector_config'.
	// These are input values the user is entering through the UI to authenticate to
	// the connector, that might also shared
	// as inputs for syncing data via the connector.
	//
	// Examples:
	//
	// if no connector values is shared during oauth flow,
	// oauth_user_input_from_connector_config_specification=[]
	// if connector values such as 'app_id' inside the top level are used to generate
	// the API url for the oauth flow,
	//   oauth_user_input_from_connector_config_specification={
	//     app_id: {
	//       type: string
	//       path_in_connector_config: ['app_id']
	//     }
	//   }
	// if connector values such as 'info.app_id' nested inside another object are used
	// to generate the API url for the oauth flow,
	//   oauth_user_input_from_connector_config_specification={
	//     app_id: {
	//       type: string
	//       path_in_connector_config: ['info', 'app_id']
	//     }
	//   }
	OauthUserInputFromConnectorConfigSpecification map[string]interface{} `json:"oauth_user_input_from_connector_config_specification,omitempty" yaml:"oauth_user_input_from_connector_config_specification,omitempty" mapstructure:"oauth_user_input_from_connector_config_specification,omitempty"`

	AdditionalProperties interface{} `mapstructure:",remain"`
}

// OAuth specific blob. Pertains to the fields defined by the connector relating to
// the OAuth flow.
type OAuthConfigSpecificationOauthConnectorInputSpecification struct {
	// The OAuth Specific optional headers to inject while exchanging the `auth_code`
	// to `access_token` during `completeOAuthFlow` step.
	//
	// Examples:
	//   In this example the header value will be encoded with the base64 hash from
	// `client_id` and `client_secret`,
	//   to provide neccessary header to complete auth flow and obtain the
	// `access_token`.
	//
	//   {
	//     "access_token_headers": {
	//         "Authorization": "Basic {{ {{ client_id_value }}:{{ client_secret_value
	// }} | base64Encoder }}"
	//     }
	//   }
	AccessTokenHeaders map[string]interface{} `json:"access_token_headers,omitempty" yaml:"access_token_headers,omitempty" mapstructure:"access_token_headers,omitempty"`

	// The OAuth Specific optional query parameters to inject while exchanging the
	// `auth_code` to `access_token` during `completeOAuthFlow` step.
	// When this property is provided, the query params are encoded as `Json string`
	// and passed to the outgoing API request.
	//
	// Examples:
	//   {
	//     "access_token_params": {
	//         "my_query_param": "param_value",
	//         "{{ client_id_key }}": "{{ client_id_value }}"
	//     }
	//   }
	AccessTokenParams map[string]interface{} `json:"access_token_params,omitempty" yaml:"access_token_params,omitempty" mapstructure:"access_token_params,omitempty"`

	// The OAuth Specific URL templated string to obtain the `access_token`,
	// `refresh_token` etc.
	// The placeholders are replaced during the processing to provide neccessary
	// values.
	//
	// Examples:
	//   {
	//     "access_token_url": "https://auth.host.com/oauth2/token?{{ client_id_key
	// }}={{ client_id_value }}&{{ client_secret_key }}={{ client_secret_value }}&{{
	// auth_code_key }}={{ auth_code_value }}&{{ redirect_uri_key }}={{
	// {{redirect_uri_key}} | urlEncoder }}"
	//   }
	AccessTokenUrl string `json:"access_token_url" yaml:"access_token_url" mapstructure:"access_token_url"`

	// The OAuth Specific optional override to provide the custom `code` key name to
	// something like `auth_code` or `custom_auth_code`, if required by data-provider.
	//
	// Examples:
	//   {
	//     "auth_code_key": "my_custom_auth_code_key_name"
	//   }
	AuthCodeKey *string `json:"auth_code_key,omitempty" yaml:"auth_code_key,omitempty" mapstructure:"auth_code_key,omitempty"`

	// The OAuth Specific optional override to provide the custom `client_id` key
	// name, if required by data-provider.
	//
	// Examples:
	//   {
	//     "client_id_key": "my_custom_client_id_key_name"
	//   }
	ClientIdKey *string `json:"client_id_key,omitempty" yaml:"client_id_key,omitempty" mapstructure:"client_id_key,omitempty"`

	// The OAuth Specific optional override to provide the custom `client_secret` key
	// name, if required by data-provider.
	//
	// Examples:
	//   {
	//     "client_secret_key": "my_custom_client_secret_key_name"
	//   }
	ClientSecretKey *string `json:"client_secret_key,omitempty" yaml:"client_secret_key,omitempty" mapstructure:"client_secret_key,omitempty"`

	// The OAuth Specific string URL string template to initiate the authentication.
	// The placeholders are replaced during the processing to provide neccessary
	// values.
	//
	// Examples:
	//   {
	//     "consent_url": "https://domain.host.com/oauth2/authorize?{{ client_id_key
	// }}={{ client_id_value }}&{{ redirect_uri_key }}={{ {{redirect_uri_value}} |
	// urlEncoder }}&{{ scope_key }}={{ {{scope_key}} | urlEncoder }}&{{ state_key
	// }}={{ state_value }}&subdomain={{ subdomain }}"
	//   }
	ConsentUrl string `json:"consent_url" yaml:"consent_url" mapstructure:"consent_url"`

	// The OAuth Specific list of strings to indicate which keys should be extracted
	// and returned back to the input config.
	//
	// Examples:
	//   In this example, once the OAuthFlow has been completed successfully,
	//   the `access_token`, `refresh_token` and other fields like `other_field` will
	// be checked and extracted from the OAuthOutput.
	//
	//   {
	//     "extract_output": ["access_token", "refresh_token", "other_field"]
	//   }
	ExtractOutput []string `json:"extract_output,omitempty" yaml:"extract_output,omitempty" mapstructure:"extract_output,omitempty"`

	// The OAuth Specific optional override to provide the custom `redirect_uri` key
	// name to something like `callback_uri`, if required by data-provider.
	//
	// Examples:
	//   {
	//     "redirect_uri_key": "my_custom_redirect_uri_key_name"
	//   }
	RedirectUriKey *string `json:"redirect_uri_key,omitempty" yaml:"redirect_uri_key,omitempty" mapstructure:"redirect_uri_key,omitempty"`

	// The OAuth Specific string of the scopes needed to be grant for authenticated
	// user.
	//
	// Examples:
	//   {
	//     "scope": "user:read user:read_orders workspaces:read"
	//   }
	Scope *string `json:"scope,omitempty" yaml:"scope,omitempty" mapstructure:"scope,omitempty"`

	// The OAuth Specific optional override to provide the custom `scope` key name, if
	// required by data-provider.
	//
	// Examples:
	//   {
	//     "scope_key": "my_custom_scope_key_key_name"
	//   }
	ScopeKey *string `json:"scope_key,omitempty" yaml:"scope_key,omitempty" mapstructure:"scope_key,omitempty"`

	// The OAuth Specific object to provide the criteria of how the `state` query
	// param should be constructed,
	// including length and complexity.
	//
	// Examples:
	//   {
	//     "state": {
	//       "min": 7,
	//       "max": 128,
	//     }
	//   }
	State *OAuthConfigSpecificationOauthConnectorInputSpecificationState `json:"state,omitempty" yaml:"state,omitempty" mapstructure:"state,omitempty"`

	// The OAuth Specific optional override to provide the custom `state` key name, if
	// required by data-provider.
	//
	// Examples:
	//   {
	//     "state_key": "my_custom_state_key_key_name"
	//   }
	StateKey *string `json:"state_key,omitempty" yaml:"state_key,omitempty" mapstructure:"state_key,omitempty"`

	// The OAuth Specific optional override to provide the custom key name to
	// something like `expires_at`, if required by data-provider.
	//
	// Examples:
	//   {
	//     "token_expiry_key": "expires_at"
	//   }
	TokenExpiryKey *string `json:"token_expiry_key,omitempty" yaml:"token_expiry_key,omitempty" mapstructure:"token_expiry_key,omitempty"`

	AdditionalProperties interface{} `mapstructure:",remain"`
}

// The OAuth Specific object to provide the criteria of how the `state` query param
// should be constructed,
// including length and complexity.
//
// Examples:
//
//	{
//	  "state": {
//	    "min": 7,
//	    "max": 128,
//	  }
//	}
type OAuthConfigSpecificationOauthConnectorInputSpecificationState struct {
	// Max corresponds to the JSON schema field "max".
	Max *int `json:"max,omitempty" yaml:"max,omitempty" mapstructure:"max,omitempty"`

	// Min corresponds to the JSON schema field "min".
	Min *int `json:"min,omitempty" yaml:"min,omitempty" mapstructure:"min,omitempty"`

	AdditionalProperties interface{} `mapstructure:",remain"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *OAuthConfigSpecificationOauthConnectorInputSpecification) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["access_token_url"]; raw != nil && !ok {
		return fmt.Errorf("field access_token_url in OAuthConfigSpecificationOauthConnectorInputSpecification: required")
	}
	if _, ok := raw["consent_url"]; raw != nil && !ok {
		return fmt.Errorf("field consent_url in OAuthConfigSpecificationOauthConnectorInputSpecification: required")
	}
	type Plain OAuthConfigSpecificationOauthConnectorInputSpecification
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	st := reflect.TypeOf(Plain{})
	for i := range st.NumField() {
		delete(raw, st.Field(i).Name)
		delete(raw, strings.Split(st.Field(i).Tag.Get("json"), ",")[0])
	}
	if err := mapstructure.Decode(raw, &plain.AdditionalProperties); err != nil {
		return err
	}
	*j = OAuthConfigSpecificationOauthConnectorInputSpecification(plain)
	return nil
}

type StreamDescriptor struct {
	// Name corresponds to the JSON schema field "name".
	Name string `json:"name" yaml:"name" mapstructure:"name"`

	// Namespace corresponds to the JSON schema field "namespace".
	Namespace *string `json:"namespace,omitempty" yaml:"namespace,omitempty" mapstructure:"namespace,omitempty"`

	AdditionalProperties interface{} `mapstructure:",remain"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *StreamDescriptor) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["name"]; raw != nil && !ok {
		return fmt.Errorf("field name in StreamDescriptor: required")
	}
	type Plain StreamDescriptor
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	st := reflect.TypeOf(Plain{})
	for i := range st.NumField() {
		delete(raw, st.Field(i).Name)
		delete(raw, strings.Split(st.Field(i).Tag.Get("json"), ",")[0])
	}
	if err := mapstructure.Decode(raw, &plain.AdditionalProperties); err != nil {
		return err
	}
	*j = StreamDescriptor(plain)
	return nil
}

type SyncMode string

const SyncModeFullRefresh SyncMode = "full_refresh"
const SyncModeIncremental SyncMode = "incremental"

var enumValues_SyncMode = []interface{}{
	"full_refresh",
	"incremental",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SyncMode) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_SyncMode {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_SyncMode, v)
	}
	*j = SyncMode(v)
	return nil
}
